함수 호출을 위한 바인딩이 실행시에 이루어지는 제도

과정
1. 컴파일 -> 
2. 링크 ->                 (컴파일한 오브젝트 코드들을 한 덩어리로 묶어서 링크를 하는 과정)
3. 로딩 -> 
4. 실행이 이루어진다    (하드디스크에 작성된 이미지 파일 메인 메모리에 올려서 컨트롤 시행시킨다.)

대부분 언어는 컴파일이나 링크 혹은 로딩을 지행하는 과정에서 바인딩을 한다.

바인딩은 : 함수를 호출을 위한 function call을 함수정의에 연결하기에서 주소를 결정행위를 말한다.

void f()
{
    ...
}
main()
{
    ...
    f()
    ...
}
통체로 기계어로 번역하는 과정에서 함수f()을 정장해야 될 주소를 결정하게 됨.
예 : f()는 만번지에 배치 main()는 만5백번지에 배치
function call는 논리적으로 f()에 있는 자리를 컴파일이나 링크나 로드가 작업하고 난 다음에 branch 10000로 바꾼다.
void f()
{
    ...
}
main()
{
    ...
    branch 10000 이렇게 바꿔준다.
    ...
}

함수가 같은 파일에 있으면 컴파일시에 이루어지고 
함수가 만약 다른 파일에 있는 경우 링크를 하는 과정에서 파일들을 다 합치기를 시키면서 그 때 주소를 결정된다.

--------------------------------------------------------------------------------------------------------------------------
C언어와 같은 객체지향 언어가 아닌 프로개래밍들은 기본적으로 Static binding 방식으로 이루어진다. (정적 바인딩)이라고 함.
(정적 바인딩) 실행전에 호출된 함수의 주소가 결정되는 경우 
--------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------

dynamic binding (동적 바운딩)
이름이 같은 함수를 가질수 있다.
함수를 호출시 눈으로 봤을 때 어느 클레스에 있는 함수에 호출하는지 전혀 알 수 없고 

class Lion extends Animal {
	void eat() { xxxx };
}
class Rabbit extends Animal {
	void eat() { xxxx };
}
class Lion extends Animal {
	void eat() { xxxx };
}

static void main(String args[]) {
	Animal x;
	x = ???;       만약  x = new Rabbit(); 이면 Rabbit클레스에 따라 갈 것이고 Lion이면 Lion클레스의 함수를 호출할 것이다.
	x.eat();         x에 따라 가더니 Lion인지 Rabbit인지 알 수 가 있다.
}

- if 문의 현격한 감소
- 프로그램의 유연성 증가
- 보수유지성(maintenence) 증대




